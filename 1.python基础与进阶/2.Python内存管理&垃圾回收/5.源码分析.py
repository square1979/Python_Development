"""
1.float 结构体：
    （1）如果缓存列表free_list 中有可用对象，则从free_list链表中拿出来一个，否则重新开辟内存
    （2）引用对象 计数器加一 销毁对象 计数器减一
    （3）检测当前free_list数量是否满了，如果已经满了则直接将对象销毁

2.list 结构体：
    （1）如果free_list中有缓存的对象，则直接从free_list中获取一个对象来使用，如果没有需要开辟内存初始化对象
    （2）创建完对象 将其放到refchain链表中
    （3）分析回收的零代的数量

3.当零代达到阈值，1代开始扫描；当1代达到阈值时会将上一代和下一代都参与扫描

4.如果扫描 0代 young = 0代，old = 1代/2代； 1代 young= 1代 old = 2代

总结：0.在python中维护了⼀个refchain的双向环状链表，这个链表中存储程序创建的所有对象，每种类型的对
        象中都有⼀个ob_refcnt引⽤计数器的值，引⽤个数 + 1、-1 ，最后当引⽤计数器变为0时会进⾏垃圾回
        收（对象销毁、refchain中移除）。
        但是，在python中对于那些可以有多个元素组成的对象可能会存在循环引用的问题，为了解决这个问题
        python⼜引⼊了标记清除和分代回收，在其内部为了4个链表，
            refchain 【引用链表是一个内部机制，用于跟踪所有的对象和管理引用计数】
            2代，10次  包含从中生代晋升的对象。初始阈值为10次（表示中生代经过10次回收后，老年代进行一次回收）。回收频率最低。
            1代，10次  包含从年轻代晋升的对象。初始阈值为10次（表示年轻代经过10次回收后，中生代进行一次回收）。回收频率适中。
            0代，700个 初始阈值为700。包含新创建的对象。回收频率最高。
        在源码内部当达到各自的阈值时，就会触发扫描链表进⾏标记清除的动作（有循环则各自-1）
     1.对于简单的、不可变的对象如 float，int 和 str，这些对象创建时会直接使用引用计数来管理。
     2.对于复杂的对象如 list，不仅使用引用计数【ob_refcnt】，还会参与分代回收。当某一代的对象数量达到某个阈值时，
        垃圾回收器会进行扫描。如果没有找到可以回收的对象，则允许继续创建新对象。
     3.垃圾回收机制负责对象的销毁，当引用计数为零或检测到循环引用时，会触发回收。

"""
